:imagesdir: images/
:source-highlighter: highlightjs
:numbered:
:unsafe:
:icons: font

ifdef::env-github[]
:outfilesuffix: .adoc
:caution-caption: :fire:
:important-caption: :exclamation:
:note-caption: :paperclip:
:tip-caption: :bulb:
:warning-caption: :warning:
endif::[]

= Padr√µes de Projetos Comportamentais

== Template Method (M√©todo Modelo) image:template.png[link=https://www.flaticon.com/authors/monkik]

NOTE: https://youtu.be/rg8_0f6bWWo[V√≠deo de apresenta√ß√£o do padr√£o.]

=== Defini√ß√£o

// tag::definicao[]
üìò"Especifica o esqueleto de um algoritmo dentro de um m√©todo, transferindo alguns de seus passos pras subclasses. Permite que as subclasses alterem certos passos do algoritmo sem alterar a estrutura dele." <<UCPP>>
// end::definicao[]

=== Aplicabilidade

Pode ser aplicado quando:

// tag::aplicabilidade[]
- um m√©todo (algoritmo) possuir determinados passos definidos mas outros n√£o; a implementa√ß√£o destes outros passos variar de uma subclasse para outra.
- voc√™ come√ßar a implementar um m√©todo em diversas subclasses e verificar que existem partes comuns (c√≥digo duplicado) e outras partes que mudam de uma subclasse para outra.
// end::aplicabilidade[]

=== Modelagem do Padr√£o

image:template-method-base.png[]

A classe que implementar√° o Template Method realmente deve ser uma classe abstrata ou uma interface do Java 8+ com um m√©todo `default` (que possui implementa√ß√£o). No diagrama, o `templateMethod()` √© que implementa o padr√£o. Ele que define a estrutudo do algoritmo a ser implementado.
Os m√©todos como `operacaoPrimitivaN()` s√£o ent√£o m√©todos abstratos, que definem parte da implementa√ß√£o do algoritmo do `templateMethod()`.
Tais opera√ß√µes primitivas s√£o ent√£o chamadas em algum lugar dentro do `templateMethod()`.
Cada subclasse pode ter sua pr√≥pria implementa√ß√£o de cada uma destas opera√ß√µes.

Um projeto de exemplo para o diagrama apresentado est√° dispon√≠vel link:modelagem[aqui]. Ele deve ser alterado para incluir as mudan√ßas necess√°rias para o problema espec√≠fico que voc√™ estiver resolvendo com o padr√£o.

=== Princ√≠pios utilizados

- https://en.wikipedia.org/wiki/Open‚Äìclosed_principle[Open/Closed Principle (OCP)]: separa as partes que mudam (as opera√ß√µes primitivas/comportamentos) de dentro da classe que as utiliza. Isto torna a classe "aberta para extens√£o e fechada para modifica√ß√£o" (em rela√ß√£o aos comportamentos).
- https://en.wikipedia.org/wiki/Single_responsibility_principle[Single Responsibility Principle (SRP)]: a classe que usa os comportamentos n√£o tem a responsabilidade de implementar estes comportamentos. 

=== Exemplo: Leitura de Retorno de Boletos

pass:[<a name="boleto"></a>]

Anteriormente aplicamos o padr√£o link:../strategy[Strategy] para implementar a leitura de retorno de boletos banc√°rios.
Como pudemos perceber, o c√≥digo do m√©todo que l√™ arquivos do Banco do Brasil √© muito parecido com o do Bradesco, havendo
muita duplica√ß√£o de c√≥digo. Neste caso, podemos adicionalmente aplicar o padr√£o Template Method para definir uma estrutura comum
para o algoritmo de leitura de arquivos de retorno, isolando as partes que alteram em m√©todos nas subclasses.

O c√≥digo fonte do projeto convencional para leitura de arquivos de retorno est√° dispon√≠vel link:retorno-boleto-template[aqui] (link:https://kinolien.github.io/gitzip/?download=/manoelcampos/padroes-projetos/tree/master/comportamentais/template-method/retorno-boleto-template[zip]). Tente primeiro fazer sua implementa√ß√£o a partir da leitura do diagrama, para depois analisar o c√≥digo disponibilizado.

pass:[<a name="functional"></a>]

=== Strategy + Template Method

Voc√™ pode ter percebido que a modelagem do Template Method usa heran√ßa,
indo contra a recomenda√ß√£o de https://en.wikipedia.org/wiki/Composition_over_inheritance[Favorecer Composi√ß√£o no lugar de Heran√ßa]. E se analisarmos tudo que foi abordado no padr√£o link:../strategy/[Strategy], composi√ß√£o traz flexibilidade.

Ent√£o, se precisarmos trocar a implementa√ß√£o do algoritmo espec√≠fico de leitura de arquivos de retorno
de um banco por outro, podemos aplicar o padr√£o Strategy em conjunto com o Template Method.
Mas neste caso, o algoritmo a ser trocado √© apenas uma parte espec√≠fica
de todo o algoritmo de processamento de tais arquivos.
Isto porque, a parte de leitura do arquivo n√£o muda, apenas
como os dados s√£o extra√≠dos de cada linha obtida que sim.

// O projeto link:retorno-boleto-template-and-strategy[retorno-boleto-template-and-strategy] mostra uma implementa√ß√£o puramente OO que une os dois padr√µes. (projeto apenas no repo local)

=== Modelagem utilizando Programa√ß√£o Funcional

A modelagem do padr√£o utilizando programa√ß√£o funcional √© extremamente simples.
Teremos apenas uma classe concreta (no lugar de abstrata) e n√£o necessariamente precisaremos de sub-classes.
Assim, o diagrama b√°sico √© apenas uma √∫nica classe como abaixo.

image:template-method-funcional.png[]

O `templateMethod()` ent√£o deve chamar as opera√ß√µes primitivas internamente. Estas s√£o definidas como atributos do tipo `Function` (por exemplo),
indicando que eles armazenam a implementa√ß√£o de uma fun√ß√£o. √â a mesma l√≥gica que utilizamos para o link:../strategy/retorno-boleto-funcional[projeto funcional para o padr√£o Strategy].

O c√≥digo fonte do projeto funcional para leitura de arquivos de retorno est√° dispon√≠vel link:retorno-boleto-template-funcional[aqui] (link:https://kinolien.github.io/gitzip/?download=/manoelcampos/padroes-projetos/tree/master/comportamentais/template-method/retorno-boleto-template-funcional[zip]).

== Modelagem convencional **SEM** o padr√£o Template Method

Uma modelagem convencional que n√£o utiliza o Template Method √© normalmente modelada como apresentado no diagrama a seguir.

image:no-template-method.png[]

Utilizando o padr√£o:

- `method()` na superclasse √© concreto;
- as opera√ß√µes primitivas ser√£o abstratas na superclasse e ter√£o comportamentos diferentes em cada subclasse. 

Sem utilizar o padr√£o (como √© mostrado acima):

- temos apenas o `method()` que √© abstrato na superclasse e ter√£o comportamentos diferentes em cada subclasse;
- n√£o temos opera√ß√µes primitivas.

Como j√° discutido, isso leva √† duplica√ß√£o de c√≥digo quando as implementa√ß√µes do `method()` em cada subclasse mudam em apenas algumas partes.
Caso as subclasses precisem apenas estender o `method()` da superclasse (adicionando opera√ß√µes no in√≠cio ou no final do m√©todo), 
podemos definir uma implementa√ß√£o base na superclasse e apenas estender o m√©todo nas subclasses.
Isto poderia ser implementado em uma subclasse simplesmente com o c√≥digo abaixo:

// tag::method-override[]
[source,java,linenums]
----
public SubClasse1 extends ClasseAbstrata {
    @Override
    public TipoRetorno method(){
        TipoRetorno valor = super.method();
        operacaoPrimitiva1();
        operacaoPrimitiva2();
        operacaoPrimitivaN();
        
        return valor;
    }
}
----
// end::method-override[]

Neste caso, estamos estendendo o m√©todo apenas executando algumas opera√ß√µes depois da chamada do m√©todo na superclasse.
Poder√≠amos tamb√©m executar tais opera√ß√µes antes e/ou depois, de acordo com as necessidades, como:

[source,java,linenums]
----
public SubClasse1 extends ClasseAbstrata {
    @Override
    public TipoRetorno method(){
        operacaoPrimitiva1();
        operacaoPrimitiva2();
        TipoRetorno valor = super.method();
        operacaoPrimitivaN();

        return valor;
    }
}
----

No entanto, o algoritmo base definido no `method()` na superclasse pode ser completamente modificado por qualquer subclasse,
o que normalmente √© algo indesejado. Podemos fazer isso apenas eliminando a chamada `super.method()`.
Para isto, poder√≠amos simplesmente definir o `method()` na superclasse como `final`,
indicando que o m√©todo n√£o pode ser sobrescrito nas subclasses.
Por outro lado, tal abordagem impede que as subclasses possam incluir mais opera√ß√µes como mostrado acima.

Adicionalmente, com a abordagem acima, n√£o temos como garantir que cada opera√ß√£o primitiva ser√° inclu√≠da nas subclasses
no exato local onde elas precisam ser executadas ou se mesmo todas as opera√ß√µes esperadas ser√£o inclu√≠das, 
o que pode gerar erros e resultados incorretos.
Por exemplo, imagine que a `operacaoPrimitiva2()` precisasse:

- adicionar conte√∫do em um arquivo que s√≥ seria criado ap√≥s a chamada de `super.method()`;
- ou usar um valor retornado pelo `super.method()`.

Com a implementa√ß√£o mostrada acima, n√£o temos como garantir nada disso. 
Logo, temos que recorrer ao padr√£o Template Method.

== Detalhes de Implementa√ß√£o

Dependendo de como voc√™ implementar o padr√£o, dever√° estar atento a alguns detalhes.
Em qualquer implementa√ß√£o, uma subclasse pode subescrever tal m√©todo e mudar completamente toda a implementa√ß√£o do algoritmo, o que √© algo que normalmente queremos evitar quando usamos o padr√£o. Isto foi discutido na se√ß√£o acima para a implementa√ß√£o sem o padr√£o. 

No entanto, como as partes do algoritmo que alteram foram isoladas nas opera√ß√µes primitivas, as subclasses n√£o devem modificar o `templateMethod()` na superclasse (veja o primeiro diagrama). Assim, com o padr√£o podemos definir o `templateMethod()` como `final` (o que n√£o podemos sem o padr√£o). Isto impede que subclasses possam alterar a implementa√ß√£o dele, mas somente das opera√ß√µes primitivas.

== Padr√µes Relacionados

Padr√µes que possuem similaridades ou podem ser usados em conjunto:

- link:../strategy[Strategy]
- Command

== Onde o padr√£o √© usado no JDK

Os seguintes m√©todos n√£o abstratos nas classe abaixo s√£o exemplos de uso do Template Method no JDK:

- `AbstractList.add`, `AbstractList.addAll`, `AbstractMap.putAll`
- `InputStream.read`, `OutputStream.write`, `Reader.read` e `Writer.write`.

== Exerc√≠cios

=== Strategy x Template Method

Qual a diferen√ßa entre Strategy e Template Method, j√° que os dois est√£o relacionados √† estrutura para implementa√ß√£o de algoritmos?

=== Processo de finaliza√ß√£o de uma compra

Considere um sistema de loja onde voc√™ pode comprar v√°rios itens.
Do ponto de vista da loja, √© ent√£o registrada uma venda que pode possuir v√°rios itens.
Ao finalizar tal venda, algumas opera√ß√µes devem ser finalizadas:

1. reservar produto no estoque (para impedir que seja vendido para outro usu√°rio);
2. realizar pagamento;
3. emitir nota fiscal;
4. encaminhar solicita√ß√£o para pr√≥ximo setor respons√°vel.

Dependendo se o cliente est√° na loja f√≠sica ou virtual,
algumas etapas do processo de finaliza√ß√£o da venda podem ser diferentes ou nem existirem.

Se o cliente est√° na loja virtual, o processo de realiza√ß√£o do pagamento deve ser feito online,
a partir da gera√ß√£o de um boleto banc√°rio ou pelo n√∫mero do cart√£o de cr√©dito.

Se estiver na loja f√≠sica, o pagamento pode ser por:

- dinheiro;
- carn√™ para pagamento na loja ou boleto (nos dois casos, n√£o requer dados adicionais do cliente pois tudo deve estar no cadastro dele);
- cart√£o de cr√©dito/d√©bito f√≠sico, que deve ser inserido na m√°quina de cart√£o e o sistema deve aguardar a confirma√ß√£o da compra pela m√°quina.

A emiss√£o da nota fiscal deve obrigatoriamente ser eletr√¥nica atualmente. No entanto,
se a venda for pela loja f√≠sica, caso o cliente n√£o tenha email cadastrado, a nota √© gerada mas n√£o √© enviada a ele.
Adicionalmente, o sistema deve solicitar a impress√£o da nota para entrega ao cliente.

Por fim, o setor para o qual o tr√¢mite ap√≥s a venda deve seguir tamb√©m muda, de acordo com a loja em que o cliente est√°.
Na loja virtual, o pedido deve ser enviado para o setor de separa√ß√£o de produtos,
enquanto na loja f√≠sica deve ser enviado para o setor de entrega de produtos.

A partir do diagrama abaixo, implemente as classes apresentadas aplicando o padr√£o Template Method.
Observe que apenas os relacionamentos foram definidos. Os m√©todos e atributos devem ser definidos por voc√™.
Os atributos n√£o tem import√¢ncia para a implementa√ß√£o do padr√£o. Assim, defina apenas o que for
necess√°rio para a sua implementa√ß√£o.

image:template-method-venda.png[]


